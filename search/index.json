[{"content":"Challenge Rating  Artificialness: 5/10 Skill: 3/10 Time: 5-10 minutes  Learn more about how we rate challenges here.\nThe CTF starts out by giving you a python file called crackme.py. When you run it, it just takes two numbers as input and outputs the largest. Not very helpful for finding flags, unless\u0026hellip;\nHow do we find the flag? When you open the file in any text editor, you\u0026rsquo;ll see that there\u0026rsquo;s more to this program than it seems. There\u0026rsquo;s a variable called bezos_cc_secret that seemingly has gibberish in it. But there\u0026rsquo;s another function, never used in the entire program, called decode_secret which (you guessed it) decodes bezos_cc_secret. Just call the function at the end of the program and run it again and you will have your flag.\n","date":"2021-04-09T16:06:11-06:00","permalink":"https://bmhstsa.com/post/crackme-py/","title":"crackme-py"},{"content":"Challenge Rating  Artificialness: 7/10 Skill: 5/10 Time: 3 hours  Learn more about how we rate challenges here.\nThis is another Wireshark challenge, expanding on the first challenge. Wireshark is a piece of software used to monitor network traffic.\nInitial analysis Starting off I (loogalicious) opened the file in Wireshark. After browsing through it, I noticed 90 or so flags in the responses from http://18.217.1.57/flag and the AWS EC2 token in packet 4344 caught my eye: After Wakeful-Cloud and I made a script to extract all of the flags, I realized they were red herrings. Then I found the DNS queries to *.reddshrimpandherring.com and looked through the given website but found nothing. This is the point when Wakeful-Cloud switched from helping me to actually working to solve the challenge.\nDNS queries The first thing I (Wakeful-Cloud) did towards solving this challenge was to sort by packet protocol and just familiarize myself with the capture. This also helps to weed out any noise that may have been generated (Since the noise is often generated from a different application/protocol). There were a few odd things that I noticed such as an enormous amount of invalid DNS queries to *.reddshrimpandherring.com: What really bothered me is why there were so many invalid queries. I\u0026rsquo;d expect that software designed to make lots of DNS queries would have some kind of back-off algorithm but whatever was making these requests clearly did not. The next thing I did was sort by time and just scroll through all the packets. Eventually, I noticed packet 3969: If you\u0026rsquo;re a web developer, you may recognize the 2 trailing equal-signs as the padding used by base 64. At this point, it seemed quite obvious to me that in order to solve the challenge, I\u0026rsquo;d have to combine all the invalid DNS queries together and decode it. In order to extract all the queries, I used T-Shark and the filter dns.qry.name matches \u0026quot;.*\\.reddshrimpandherring\\.com$\u0026quot; \u0026amp;\u0026amp; ip.src == 18.217.1.57 (You can use this filter in the GUI too). The command to dump all the DNS queries I used is:\n# Bash tshark -r ./shark2.pcapng -Y \u0026#39;dns.qry.name matches \u0026#34;.*\\.reddshrimpandherring\\.com$\u0026#34; \u0026amp;\u0026amp; ip.src == 18.217.1.57\u0026#39; -T fields -e dns.qry.name | uniq \u0026gt; dns.txt # Powershell tshark -r ./shark2.pcapng -Y \u0026#39;dns.qry.name matches \u0026#34;.*\\.reddshrimpandherring\\.com$\u0026#34; \u0026amp;\u0026amp; ip.src == 18.217.1.57\u0026#39; -T fields -e dns.qry.name | Get-Unique \u0026gt; dns.txt Processing the queries Now that we have a file (dns.txt) filled with unique DNS requests, we need to combine the subdomains and parse the base 64. To do this, I used the below JS script:\n//Imports const {readFileSync, writeFileSync} = require(\u0026#39;fs\u0026#39;); //Read the file const raw = readFileSync(\u0026#39;./dns.txt\u0026#39;, \u0026#39;utf-8\u0026#39;); //Split each line const lines = raw.split(\u0026#39;\\n\u0026#39;).filter(line =\u0026gt; line != \u0026#39;\u0026#39;); //Combine let base64 = \u0026#39;\u0026#39;; for (const line of lines) { //Extract the subdomain  const subdomain = /([^.]+)/.exec(line); //Append the subdomain  if (subdomain != null) { base64 += subdomain[0]; } } //Interpret the base 64 const data = Buffer.from(base64, \u0026#39;base64\u0026#39;); //Log console.log(data.toString()); Note: this script assumes your file uses Linux-style new-lines. If you\u0026rsquo;re not, be sure to update line 8 from '\\n' to whatever new-line-characters you\u0026rsquo;re using.\nIf you run this, it should write the flag to the console.\n","date":"2021-04-09T15:58:15-06:00","permalink":"https://bmhstsa.com/post/wireshark-2/","title":"Wireshark 2"},{"content":"Challenge Rating  Artificialness: 7/10 Skill: 4/10 Time: 15-30 minutes  Learn more about how we rate challenges here.\nThis challenge is a Wireshark-based challenge, which involves analyzing network traffic through Wireshark.\nWhat software do you need? Wireshark and a ROT13 decoder, which you can find online.\nWhat do you need to know in order to solve it? You need to know how to export Wireshark objects into HTTP and possibly how to recognize ROT13 encryptions if you don\u0026rsquo;t want to spend 20 minutes looking up different decryption websites.\nWhat do you actually do? Open the file in Wireshark, first of all. Then Export Objects into HTTP and click Save All. It\u0026rsquo;ll put all of the HTTP requests into the destination of your choice, mine was Downloads, and then open the %5c (which is a percent-encoded character) folder in a text editor of your choice. The text is encoded in ROT13 which I encoded after trying several other algorithms. The encrypted text contains the flag.\n","date":"2021-04-09T15:48:38-06:00","permalink":"https://bmhstsa.com/post/wireshark-doo-dooo-do-doo/","title":"Wireshark Doo Dooo Do Doo"},{"content":"Challenge Rating  Artificialness: 3/10 Skill: 7/10 Time: 4-6 hours  Learn more about how we rate challenges here.\nPreface This write-up assumes you understand what an injection vulnerability is. If you don\u0026rsquo;t you, should check out Web Gauntlet 2.\nWhat is XPath? XPath is the standard way of querying data from an XML document (Similar to SQL). There are a few basic things you need to know about XPath:\n Think of XPath queries like a file-path (/ separated, items are written in a descending, hierarchical-order) A / represents the root element A // represents any element in any location You can extract an element\u0026rsquo;s content with {Element}/text() (eg: //user/name/text() equals guest) You can get a string\u0026rsquo;s length with string-length (eg: string-length('abc') equals 3) You can get a substring with substring (eg: substring('abc', 2, 1) equals b; note: XPath is one-indexed) You filter elements with [{Condition}]  You can filter by position with [position() {Operator} {Number}] (eg: [position() = 2]; note: XPath is one-indexed) You can filter by string-matches with ['A' = 'B'] You can join different conditions together with or or and    Solving the challenge Probable Query In order to develop an injection, it helps to have a query (Although it likely won\u0026rsquo;t be the same as the actual query picoCTF uses). To develop it, think about what conditions the server uses to find a user element: does the user\u0026rsquo;s name equal a user-controlled valued and does the user\u0026rsquo;s password equal another user-controlled value? The probable query I developed was:\n//user[name/text()=\u0026#39;[USERNAME INPUT]\u0026#39; and pass/text()=\u0026#39;[PASSWORD INPUT]\u0026#39;] Developing an injection Now that we have a probably query, we can start messing around with single-quote injection to try to escape the user-controlled strings. I found using abc as the username and ' or {CONDITION} and 'a'='a as the password allows for us to run arbitrary boolean expressions on the server (Note that You're on the right path. indicates true while Login failure. indicates false). While this doesn\u0026rsquo;t allow us to return strings, it\u0026rsquo;s a start.\nExfiltrating data We know we can evaluate a boolean expression but how can we extract a string? The answer is by testing each character in a string until we get the correct character and with enough characters, the entire string.\nInitially it may seem like this a place where binary search would work well - we could possibly check if the nth character code is greater than the a certain number however the fn:string-to-codepoints function is disabled. Therefore, we will have to go through each character sequentially (Linear search). This is the part where this challenge gets very painful. The good news is that we can reasonably assume all characters are inside of the printable ASCII range (97 characters) which is far easier to guess than say Unicode (143,859 characters).\nTo expedite this process, I developed a mini library for data extraction specifically for this challenge. You can view the source code here. This took a long time to extract because I followed multiple incorrect paths (Hence the flag\u0026rsquo;s message); but I did find this XML playground to be extremely helpful for constructing XPath queries. Eventually, I was able to extract the below XML document (And the flag too):\n\u0026lt;db\u0026gt; \u0026lt;poems\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;Robert Frost\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;The Road Not Taken\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;William Carlos Williams\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;The Red Wheelbarrow\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;Pablo Neruda\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;Oda a la papa\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;Gwendolyn Brooks\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;We Real Cool\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;William Blake\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;The Tyger\u0026lt;/title\u0026gt; \u0026lt;text\u0026gt;[UNKNOWN]\u0026lt;/text\u0026gt; \u0026lt;/poem\u0026gt; \u0026lt;/poems\u0026gt; \u0026lt;users\u0026gt; \u0026lt;user\u0026gt; \u0026lt;name\u0026gt;guest\u0026lt;/name\u0026gt; \u0026lt;pass\u0026gt;thisisnottheflag\u0026lt;/pass\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user\u0026gt; \u0026lt;name\u0026gt;bob\u0026lt;/name\u0026gt; \u0026lt;pass\u0026gt;thisisnottheflageither\u0026lt;/pass\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;user\u0026gt; \u0026lt;name\u0026gt;admin\u0026lt;/name\u0026gt; \u0026lt;pass\u0026gt;picoCTF{h0p3fully_u_t0ok_th3_r1ght_xp4th_f0505d9c}\u0026lt;/pass\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;/users\u0026gt; \u0026lt;/db\u0026gt; Note: [UNKNOWN] represent strings that are very long and would take a long time to extract; you can probably make an educates guess though.\nData verification While extracting the data is very time-consuming and requires potentially thousands of HTTP requests, verifying the data is easy. For example, here\u0026rsquo;s the login credentials to verify the flag (Which could change if you\u0026rsquo;re reading this far in the future):\n Username: abc Password: ' or /db/users/user[position()=3]/pass/text() = 'picoCTF{h0p3fully_u_t0ok_th3_r1ght_xp4th_f0505d9c}' and 'a'='a  ","date":"2021-04-02T23:39:19-06:00","permalink":"https://bmhstsa.com/post/x-marks-the-spot/","title":"X Marks the Spot"},{"content":"Mod 26 This is a rot 13 cypher!\nWhat is ROT 13? ROT 13 is a cipher where every letter is rotated by 13 letters within the alphabet. It is a type of caesar cipher.\nHow can this be reversed? Rot 13 can be reversed the same way as it is encypted, by rotating the letters by thirteen charecters. In Python we can simply take the ASCII value of each letter (take out special charecters and numbers),and add thirteen, before using the modulo operator to loop backto the beginning of the alphabet.\nex = \u0026#39;cvpbPGSarkggvzrVyygelebhaqfbsebghyLicInt\u0026#39; letts = [] for i in range(len(ex)): letts.append(ex[i].lower()) letts[i] = (ord(letts[i]) - 97 + 13) % 26 letts[i] = chr(letts[i] + 97) print(letts) The output will look something like:\n[\u0026#39;p\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;g\u0026#39;] Manually add back special charecters and capitalization and you will have your flag.\nOnline Tools You can also use the following online tools to accomplish the same thing:\n dcode.fr/rot-13-cipher rot13.com cryptii.com/pipes/rot13-decoder  ","date":"2021-04-02T16:58:00-06:00","permalink":"https://bmhstsa.com/post/mod-13/","title":"Mod 13"},{"content":"Challenge Rating  Artificialness: 8/10 Skill: 2/10 Time: 3 minutes  Learn more about how we rate challenges here.\nWhat software do you need? Notepad or a text editor.\nWhat do you need to know in order to solve it? That nobody expects Notepad.\nWhat do you actually do? Open the file in Notepad and CTRL+F for picoCTF.\n","date":"2021-04-02T16:57:30-06:00","permalink":"https://bmhstsa.com/post/static-aint-always-noise/","title":"Static Aint Always Noise"},{"content":"Challenge Rating  Artificialness: 4/10 Skill: 3/10 Time: 5-10 minutes  Learn more about how we rate challenges here.\nWhat is SSH? SSH (Secure SHell) is a protocol for securely transmitting commands to a remote computer. It makes it possible to access files, run commands, and more, just from inside the terminal. More information can be found here.\nDoing the challenge Pico already gives you the command to use. When you first log in, the directory you\u0026rsquo;re in has 1of3.flag.txt and instructions-to-2of3.txt. Clearly, the flag is split up into three different files. Use the cat command to view these files and follow the instructions to get the rest of the flag. Combine each of the files in order (1of3.flag.txt, 2of3.flag.txt, and 3of3.flag.txt) to get the flag!\n","date":"2021-04-02T16:46:31-06:00","permalink":"https://bmhstsa.com/post/magikarp-ground-mission/","title":"Magikarp Ground Mission"},{"content":"Challenge Rating  Artificialness: 6/10 Skill: 4/10 Time: 10 minutes  Learn more about how we rate challenges here.\nWhat software do you need? Any type of zip extraction, 7zip or WinRAR work fine.\nWhat do you need to know in order to solve it? The aspect of this challenge is to find hidden files inside image files.\nWhat do you actually do? Archive the original file with (in my case) WinRAR, then extract it. In the extracted file, you\u0026rsquo;ll find another file and so on, so forth. Continue the archive-extract until you find a text file which contains the flag.\n","date":"2021-04-02T16:32:39-06:00","permalink":"https://bmhstsa.com/post/matryoshka-doll/","title":"Matryoshka Doll"},{"content":"Challenge Rating  Artificialness: 3/10 Skill: 6/10 Time: 30 minutes (Assuming you already solved Web Gauntlet 2)  Learn more about how we rate challenges here.\nPreface This is the followup challenge to Web Gauntlet 2 which itself is a followup to Web Gauntlet. This article assumes you\u0026rsquo;ve already solved Web Gauntlet 2.\nWhat\u0026rsquo;s different? Not a whole lot - just the maximum user input length. Our previous exploit (admi'||CHAR(1540/LENGTH( and ))||') is 29 characters long. We only need to shave off 4 characters to be within the 25 character limit, that shouldn\u0026rsquo;t be too hard.\nCondensing our payload The first thing I noticed is that the bridged string ( AND password=) contains 1 of the characters in admin: a. Since SQLite also has a SUBSTR function, we can use that bridged text meaning we can eliminate CHAR(1540/LENGTH()). This leaves us with:\nSELECT username, password FROM users WHERE username=\u0026#39;\u0026#39;||substr(\u0026#39; AND password=\u0026#39;,7,1)||\u0026#39;dmin\u0026#39;; Now the total input is only 22 characters, 3 under the limit. Sweet! So if you set the username to '||substr( and the password to ,7,1)||'dmin, you should see the flag on filter.php.\n","date":"2021-03-31T00:32:29-06:00","permalink":"https://bmhstsa.com/post/web-gauntlet-3/","title":"Web Gauntlet 3"},{"content":"Challenge Rating  Artificialness: 3/10 Skill: 6/10 Time: 2-3 hours  Learn more about how we rate challenges here.\nPreface This is the followup challenge to Web Gauntlet.\nWhat are SQL injections? SQL injections occur when a server improperly handles user input in such a way that the user can write SQL queries and run them on the server. For example, lets say we\u0026rsquo;re running a simple web server that performs a username/password lookup:\nSELECT username, password FROM users WHERE username=\u0026#39;[USERNAME INPUT]\u0026#39; AND password=\u0026#39;[PASSWORD INPUT]\u0026#39;; Even if you don\u0026rsquo;t know SQL, you can probably figure out that we\u0026rsquo;re querying the database for users with a username equal to [USERNAME INPUT] and a password equal to [PASSWORD INPUT]. Well, say an attacker were to enter '. Just a single-quote. What do you think would happen? If the server was programmed correctly, it would escape the quote or filter it out resulting in the following query:\nSELECT username, password FROM users WHERE username=\u0026#39;\u0026#39;\u0026#39;\u0026#39; AND password=\u0026#39;[PASSWORD INPUT]\u0026#39;; Note: you escape single-quotes by doubling them up in SQLite.\nBut if the server simply concatenates or adds strings together to form a query such as with the below pseudocode:\n\u0026#34;SELECT username, password FROM users WHERE username=\u0026#39;\u0026#34; + username + \u0026#34;\u0026#39; AND password=\u0026#39;\u0026#34; + password + \u0026#34;\u0026#39;;\u0026#34; This would produce the following query:\nSELECT username, password FROM users WHERE username=\u0026#39;\u0026#39;\u0026#39; AND password=\u0026#39;[PASSWORD INPUT]\u0026#39;; Note: this is actually an invalid query but bare with me.\nNotice how the syntax highlighting is different than when the server properly escapes the single-quote? That\u0026rsquo;s because we now have a single string starting with an escaped quote ('' AND password=). This is called an injection vulnerability because a crafty attacker could format the username or password in such a way that when the server concatenates the user-input together, it generates a totally different, malicious query.\nSolving the challenge One important thing to note about this challenge is that our user-input cannot contain any of the following or and true false union like = \u0026gt; \u0026lt; ; -- /* */ admin (Which can be found on the filter.php page).\nSetting the username So first we need to figure out how to query the admin user without actually typing admin (Because it\u0026rsquo;s filtered). Luckily, SQLite (The flavor of SQL this challenge uses) supports string concatenation (Adding two or more strings together). So now we can type admin with the following for the username: admi'||'n which will turn into:\nSELECT username, password FROM users WHERE username=\u0026#39;admi\u0026#39;||\u0026#39;n\u0026#39; AND password=\u0026#39;[PASSWORD INPUT]\u0026#39;; Sweet!\nSetting the password We don\u0026rsquo;t know the password and this challenge isn\u0026rsquo;t about getting the password, so we need to get more creative - think about ways of removing the AND part of the query.\nRemember how earlier when the attacker entered a single-quote (') it generated an invalid SQL query because the string kind of bridged the 2 user inputs? Well if we do something with that string, then that eliminates the password= part of the query meaning we don\u0026rsquo;t have to guess or crack the password.\nMy solution is far from elegant but I decided to kill 2 birds with one stone by using the length of the bridged string using the SQLite LENGTH function in combination with the SQLite CHAR function to generate the n in admin via character codes.\nIn essence, the bridged string is  AND password= (14 characters long) and the ASCII character code for n is 110. So then I multiplied 14 by 110 which is 1540. Finally I concatenated an empty string at the end to make sure there wasn\u0026rsquo;t an unmatched single-quote. When the server executes the query, it will undo the multiplication and return the correct character code. I know this sounds confusing but it\u0026rsquo;s somewhat simple when you see it written out:\nSELECT username, password FROM users WHERE username=\u0026#39;admi\u0026#39;||CHAR(1540/LENGTH(\u0026#39; AND password=\u0026#39;))||\u0026#39;\u0026#39;; So if you set the username to admi'||CHAR(1540/LENGTH( and the password to ))||', you should see the flag on filter.php. Again, not the most elegant solution. If you want to see a more elegant solution, check out the sequel to this challenge, Web Gauntlet 3.\n","date":"2021-03-30T23:26:46-06:00","permalink":"https://bmhstsa.com/post/web-gauntlet-2/","title":"Web Gauntlet 2"},{"content":"Challenge Rating  Artificialness: 5/10 Skill: 3/10 Time: 5 minutes  Learn more about how we rate challenges here.\nWhat are HTTP verbs? Normally when you access a website, your browser makes an HTTP request to GET content from the server. However, your browser isn\u0026rsquo;t always fetching data from a server, sometimes it POSTs data too (Such as when logging in to a website). HTTP verbs are the standardized method for telling the server what to do. The most common HTTP verbs are:\n GET: fetch data from a server (eg: retrieve an HTML file) HEAD: check what the server will do before making a GET request (eg: check response size before fetching something) POST: post data to a server (eg: log in to a website) PUT: update an existing resource DELETE: delete a resource  Solving the challenge Although the Get in Get Ahead may throw you off, remember that web browsers make GET requests by default so this challenge may be a little too easy if all you had to do was just visit the link with a browser and open the inspector. Instead, focus on the Ahead part - as in a HEAD request. If you use a tool such as Postman, this is fairly easy to do: Please note that the flag is a header, not the response body.\n","date":"2021-03-30T22:38:13-06:00","permalink":"https://bmhstsa.com/post/get-ahead/","title":"Get Ahead"},{"content":"We rank CTF challenges on the following metrics:\n Artificialness Skill Time  Artificialness This metric measures how contrived or artificial a challenge is. This metric is measured on a scale from 1 to 10 where 1 represents a very realistic challenge while a 10 represents a very artificial challenge.\nSkill This metric measures how much skill a challenge requires to solve. If multiple ways of solving a challenge are available, this metrics should reflect the easiest one. This metric is also measured on a scale from 1 to 10 where 1 represents a challenge a complete novice could solve and a 10 represents a challenge only subject experts could solve.\nTime This metric measures how much time a challenge requires to solve on the first time without any outside help. This metric is measured in hours and minutes.\n","date":"2021-03-30T22:31:14-06:00","permalink":"https://bmhstsa.com/post/rating/","title":"Rating"}]